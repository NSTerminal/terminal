// Copyright 2021-2023 Aidan Sun and the Network Socket Terminal contributors
// SPDX-License-Identifier: GPL-3.0-or-later

module;
#include <string>

export module os.errcheck;
import os.error;

export {
    // clang-format off
    // Predicate functors to check success based on return code
    struct CheckTrue { bool operator()(auto rc) { return static_cast<bool>(rc); } } checkTrue;
    struct CheckZero { bool operator()(auto rc) { return rc == 0; } } checkZero;
    struct CheckNonError { bool operator()(auto rc) { return rc != -1; } } checkNonError;

    // Projection functors to turn return codes into numeric error codes
    struct UseLastError { System::ErrorCode operator()(auto) { return System::getLastError(); } } useLastError;
    struct UseReturnCode { System::ErrorCode operator()(auto rc) { return rc; } } useReturnCode;
    struct UseReturnCodeNeg { System::ErrorCode operator()(auto rc) { return -rc; } } useReturnCodeNeg;

    // clang-format on

    // Structure to contain a function's textual name and return code.
    template <class T>
    struct FnResult {
        T rc{};           // Return code
        std::string name; // Function name
    };

#ifdef __clang__
    template <class T>
    FnResult(T, std::string) -> FnResult<T>;
#endif

    // Calls a system function, and throws an exception if its return code does not match a success value.
    // The success condition and thrown error code can be changed with predicate and projection functions.
    template <class T, class Pred = CheckNonError, class Proj = UseLastError>
    T call(const FnResult<T>& fn, Pred checkFn = {}, Proj transformFn = {}, System::ErrorType type = System::ErrorType::System) {
        T rc = fn.rc;
        System::ErrorCode error = transformFn(rc);

        return (checkFn(rc) || !System::isFatal(error)) ? rc : throw System::SystemError{ error, type, fn.name };
    }
}
